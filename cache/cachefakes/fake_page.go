// This file was generated by counterfeiter
package cachefakes

import (
	"sync"

	"github.com/calebamiles/github-client/cache"
)

type FakePage struct {
	KeyForPageStub        func(pageURL string) (cacheKey string, err error)
	keyForPageMutex       sync.RWMutex
	keyForPageArgsForCall []struct {
		pageURL string
	}
	keyForPageReturns struct {
		result1 string
		result2 error
	}
	FetchPageByKeyStub        func(cacheKey string) (page []byte, err error)
	fetchPageByKeyMutex       sync.RWMutex
	fetchPageByKeyArgsForCall []struct {
		cacheKey string
	}
	fetchPageByKeyReturns struct {
		result1 []byte
		result2 error
	}
	AddPageStub        func(pageURL string, cacheKey string, page []byte) error
	addPageMutex       sync.RWMutex
	addPageArgsForCall []struct {
		pageURL  string
		cacheKey string
		page     []byte
	}
	addPageReturns struct {
		result1 error
	}
	OpenStub        func() error
	openMutex       sync.RWMutex
	openArgsForCall []struct{}
	openReturns     struct {
		result1 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct{}
	closeReturns     struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePage) KeyForPage(pageURL string) (cacheKey string, err error) {
	fake.keyForPageMutex.Lock()
	fake.keyForPageArgsForCall = append(fake.keyForPageArgsForCall, struct {
		pageURL string
	}{pageURL})
	fake.recordInvocation("KeyForPage", []interface{}{pageURL})
	fake.keyForPageMutex.Unlock()
	if fake.KeyForPageStub != nil {
		return fake.KeyForPageStub(pageURL)
	} else {
		return fake.keyForPageReturns.result1, fake.keyForPageReturns.result2
	}
}

func (fake *FakePage) KeyForPageCallCount() int {
	fake.keyForPageMutex.RLock()
	defer fake.keyForPageMutex.RUnlock()
	return len(fake.keyForPageArgsForCall)
}

func (fake *FakePage) KeyForPageArgsForCall(i int) string {
	fake.keyForPageMutex.RLock()
	defer fake.keyForPageMutex.RUnlock()
	return fake.keyForPageArgsForCall[i].pageURL
}

func (fake *FakePage) KeyForPageReturns(result1 string, result2 error) {
	fake.KeyForPageStub = nil
	fake.keyForPageReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePage) FetchPageByKey(cacheKey string) (page []byte, err error) {
	fake.fetchPageByKeyMutex.Lock()
	fake.fetchPageByKeyArgsForCall = append(fake.fetchPageByKeyArgsForCall, struct {
		cacheKey string
	}{cacheKey})
	fake.recordInvocation("FetchPageByKey", []interface{}{cacheKey})
	fake.fetchPageByKeyMutex.Unlock()
	if fake.FetchPageByKeyStub != nil {
		return fake.FetchPageByKeyStub(cacheKey)
	} else {
		return fake.fetchPageByKeyReturns.result1, fake.fetchPageByKeyReturns.result2
	}
}

func (fake *FakePage) FetchPageByKeyCallCount() int {
	fake.fetchPageByKeyMutex.RLock()
	defer fake.fetchPageByKeyMutex.RUnlock()
	return len(fake.fetchPageByKeyArgsForCall)
}

func (fake *FakePage) FetchPageByKeyArgsForCall(i int) string {
	fake.fetchPageByKeyMutex.RLock()
	defer fake.fetchPageByKeyMutex.RUnlock()
	return fake.fetchPageByKeyArgsForCall[i].cacheKey
}

func (fake *FakePage) FetchPageByKeyReturns(result1 []byte, result2 error) {
	fake.FetchPageByKeyStub = nil
	fake.fetchPageByKeyReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakePage) AddPage(pageURL string, cacheKey string, page []byte) error {
	var pageCopy []byte
	if page != nil {
		pageCopy = make([]byte, len(page))
		copy(pageCopy, page)
	}
	fake.addPageMutex.Lock()
	fake.addPageArgsForCall = append(fake.addPageArgsForCall, struct {
		pageURL  string
		cacheKey string
		page     []byte
	}{pageURL, cacheKey, pageCopy})
	fake.recordInvocation("AddPage", []interface{}{pageURL, cacheKey, pageCopy})
	fake.addPageMutex.Unlock()
	if fake.AddPageStub != nil {
		return fake.AddPageStub(pageURL, cacheKey, page)
	} else {
		return fake.addPageReturns.result1
	}
}

func (fake *FakePage) AddPageCallCount() int {
	fake.addPageMutex.RLock()
	defer fake.addPageMutex.RUnlock()
	return len(fake.addPageArgsForCall)
}

func (fake *FakePage) AddPageArgsForCall(i int) (string, string, []byte) {
	fake.addPageMutex.RLock()
	defer fake.addPageMutex.RUnlock()
	return fake.addPageArgsForCall[i].pageURL, fake.addPageArgsForCall[i].cacheKey, fake.addPageArgsForCall[i].page
}

func (fake *FakePage) AddPageReturns(result1 error) {
	fake.AddPageStub = nil
	fake.addPageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePage) Open() error {
	fake.openMutex.Lock()
	fake.openArgsForCall = append(fake.openArgsForCall, struct{}{})
	fake.recordInvocation("Open", []interface{}{})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub()
	} else {
		return fake.openReturns.result1
	}
}

func (fake *FakePage) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakePage) OpenReturns(result1 error) {
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePage) Close() error {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	} else {
		return fake.closeReturns.result1
	}
}

func (fake *FakePage) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakePage) CloseReturns(result1 error) {
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.keyForPageMutex.RLock()
	defer fake.keyForPageMutex.RUnlock()
	fake.fetchPageByKeyMutex.RLock()
	defer fake.fetchPageByKeyMutex.RUnlock()
	fake.addPageMutex.RLock()
	defer fake.addPageMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cache.Page = new(FakePage)
